#!/usr/bin/env node

const fs = require('fs');
const process = require('process');
const cvs = require('./lib/convSymbols')

function initCapWords( l ) {
  let words = l.split(' ');
  words = words.map( w => `${w[0]}${w.slice(1).toLowerCase()}` );
  return words.join(' ');
}

function strReplace( l, i, size, nStr ) {
  return l.slice(0,i) + nStr + l.slice(i+size);
}

const chr_tm = 0252
const buf_tm = Buffer.from( '&#153;' )    // trademark
const chr_cp = 0250
const buf_cp = Buffer.from( '&#169;' )    // copyright

function convertSymbolsInBuffer( d ) {
  let buf2 = Buffer.alloc(d.length + 500)
  let i = j = 0

  for (i = 0; i < d.length; i++) {
    if (d[i] == chr_tm) { //console.log(`tm found at ${i}`)
      buf_tm.copy(buf2,j)          // buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])
      j += buf_tm.length
    } else if (d[i] == chr_cp) { //console.log(`cp found at ${i}`)
      buf_cp.copy(buf2,j)          // buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])
      j += buf_cp.length
    } else {
      buf2[j] = d[i]
      j += 1
    }
  }
  return buf2.subarray(0,j).toString()
}

function procLine( l, cs ) {
  if (l.match(/PREFACE/)) {
    console.log(``);
    console.log(`# Preface`);
  } else if (l.match(/CHAPTER /)) {
    let z = l.indexOf(':')
    let sname = initCapWords( l.slice(z+2) );
    console.log(`# ${sname}`);
  } else if (l.match(/SECTION:/)) {
    let sname = initCapWords( l.slice(9) );
    console.log(`## ${sname}`);
  } else if (l.match(/\[\[Figure /)) {
    let iname = "newfigs/fig1.jpg"  // maybe use a table to convert figure # to file name?
    let icaption = "Figure 1-1: The AFS Architecture"
    //console.log(`![figure 1](${iname}) </p> <p>${icaption}</p>`);
    console.log(`<img src="${iname}" alt="${icaption}" height="458" width="638"/> <p>${icaption}</p>`);
  } else if (l.match(/PROGRAM/)) {
    //console.log("~~~");
    if (cs != "in program") {
      console.log('<pre>');
    } else {
      console.log('</pre>');
    }
    cs = (cs == "in program") ? 'normal' : 'in program';
  } else {
    l = cvs.convSymbols(l);
    console.log(l)
  }
  return cs;
}

function procChapter( c ) {
  //console.log(`chapter ${c}`);
  const data = fs.readFileSync(c);
  //console.log(`${c}: data ${data.length}`);
  const lines = convertSymbolsInBuffer(data).split('\n')      // converts tm and (c)
  //console.log(`${c}: lines ${lines.length}`);

  let curState = 'normal';
  lines.forEach( l => {
    curState = procLine(l, curState); // tracks state and outputs markdown
  });
}

const D = "archive/";
let bookChaps = [ 'CH00R.txt'];

if (process.argv.length > 2) {
  bookChaps = process.argv.slice(2);
  console.error(`doing: ${bookChaps}`);
}
bookChaps.map( c => D+c ).forEach( c => procChapter(c) );
